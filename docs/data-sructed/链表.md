# TypeScript 链表数据结构知识梳理

## 一、链表概述

### 什么是链表？

链表是一种**线性数据结构**，由一系列节点组成，每个节点包含：
- **数据域**：存储实际数据
- **指针域**：指向下一个节点的引用

```
┌───┬────┐     ┌───┬────┐     ┌───┬────┐     ┌───┬────┐
│ 1 │ ──┼────►│ 2 │ ──┼────►│ 3 │ ──┼────►│ 4 │null│
└───┴────┘     └───┴────┘     └───┴────┘     └───┴────┘
  Node           Node           Node           Node
```

### 与数组对比

| 特性 | 数组 | 链表 |
|------|------|------|
| 内存分配 | 连续 | 分散 |
| 访问方式 | 随机访问 O(1) | 顺序访问 O(n) |
| 插入/删除 | O(n) | O(1) |
| 空间占用 | 固定 | 动态 |

---

## 二、链表类型

### 1. 单向链表（Singly Linked List）

```typescript
// 节点定义
class ListNode<T> {
    value: T;
    next: ListNode<T> | null = null;
    
    constructor(value: T) {
        this.value = value;
    }
}

// 链表类
class SinglyLinkedList<T> {
    head: ListNode<T> | null = null;
    tail: ListNode<T> | null = null;
    length: number = 0;
    
    // 添加到尾部
    append(value: T): void {
        const node = new ListNode(value);
        if (!this.tail) {
            this.head = this.tail = node;
        } else {
            this.tail.next = node;
            this.tail = node;
        }
        this.length++;
    }
    
    // 添加到头部
    prepend(value: T): void {
        const node = new ListNode(value);
        node.next = this.head;
        this.head = node;
        if (!this.tail) this.tail = node;
        this.length++;
    }
    
    // 删除第一个匹配的节点
    delete(value: T): boolean {
        if (!this.head) return false;
        
        if (this.head.value === value) {
            this.head = this.head.next;
            this.length--;
            return true;
        }
        
        let current = this.head;
        while (current.next) {
            if (current.next.value === value) {
                current.next = current.next.next;
                this.length--;
                return true;
            }
            current = current.next;
        }
        return false;
    }
    
    // 查找节点
    find(value: T): ListNode<T> | null {
        let current = this.head;
        while (current) {
            if (current.value === value) return current;
            current = current.next;
        }
        return null;
    }
    
    // 反转链表
    reverse(): void {
        let prev: ListNode<T> | null = null;
        let current = this.head;
        this.tail = this.head;
        
        while (current) {
            const next = current.next;
            current.next = prev;
            prev = current;
            current = next;
        }
        this.head = prev;
    }
}
```

### 2. 双向链表（Doubly Linked List）

```typescript
class DoublyListNode<T> {
    value: T;
    prev: DoublyListNode<T> | null = null;
    next: DoublyListNode<T> | null = null;
    
    constructor(value: T) {
        this.value = value;
    }
}

class DoublyLinkedList<T> {
    head: DoublyListNode<T> | null = null;
    tail: DoublyListNode<T> | null = null;
    length: number = 0;
    
    append(value: T): void {
        const node = new DoublyListNode(value);
        if (!this.tail) {
            this.head = this.tail = node;
        } else {
            node.prev = this.tail;
            this.tail.next = node;
            this.tail = node;
        }
        this.length++;
    }
    
    prepend(value: T): void {
        const node = new DoublyListNode(value);
        if (!this.head) {
            this.head = this.tail = node;
        } else {
            node.next = this.head;
            this.head.prev = node;
            this.head = node;
        }
        this.length++;
    }
    
    // 删除节点（双向链表的优势）
    delete(value: T): boolean {
        let current = this.head;
        while (current) {
            if (current.value === value) {
                if (current.prev) current.prev.next = current.next;
                if (current.next) current.next.prev = current.prev;
                if (current === this.head) this.head = current.next;
                if (current === this.tail) this.tail = current.prev;
                this.length--;
                return true;
            }
            current = current.next;
        }
        return false;
    }
}
```

### 3. 循环链表（Circular Linked List）

```typescript
class CircularLinkedList<T> {
    tail: ListNode<T> | null = null;
    length: number = 0;
    
    append(value: T): void {
        const node = new ListNode(value);
        if (!this.tail) {
            node.next = node;
            this.tail = node;
        } else {
            node.next = this.tail.next;
            this.tail.next = node;
            this.tail = node;
        }
        this.length++;
    }
}
```

---

## 三、常见操作实现

### 1. 链表反转

```typescript
// 方法1：迭代反转
function reverseList<T>(head: ListNode<T> | null): ListNode<T> | null {
    let prev: ListNode<T> | null = null;
    let current = head;
    
    while (current) {
        const next = current.next;
        current.next = prev;
        prev = current;
        current = next;
    }
    return prev;
}

// 方法2：递归反转
function reverseListRecursive<T>(head: ListNode<T> | null): ListNode<T> | null {
    if (!head || !head.next) return head;
    
    const newHead = reverseListRecursive(head.next);
    head.next.next = head;
    head.next = null;
    return newHead;
}
```

### 2. 检测环

```typescript
function hasCycle(head: ListNode<any> | null): boolean {
    let slow = head;
    let fast = head;
    
    while (fast && fast.next) {
        slow = slow!.next;
        fast = fast.next.next;
        if (slow === fast) return true;
    }
    return false;
}
```

### 3. 合并两个有序链表

```typescript
function mergeTwoLists<T>(l1: ListNode<T> | null, l2: ListNode<T> | null): ListNode<T> | null {
    const dummy = new ListNode(null as any);
    let current = dummy;
    
    while (l1 && l2) {
        if (l1.value <= l2.value) {
            current.next = l1;
            l1 = l1.next;
        } else {
            current.next = l2;
            l2 = l2.next;
        }
        current = current.next;
    }
    current.next = l1 || l2;
    return dummy.next;
}
```

### 4. 删除倒数第 N 个节点

```typescript
function removeNthFromEnd(head: ListNode<any>, n: number): ListNode<any> | null {
    const dummy = new ListNode(0);
    dummy.next = head;
    let fast = dummy;
    let slow = dummy;
    
    for (let i = 0; i <= n; i++) {
        fast = fast.next!;
    }
    
    while (fast) {
        fast = fast.next;
        slow = slow.next!;
    }
    
    slow.next = slow.next!.next;
    return dummy.next;
}
```

---

## 四、时间复杂度

| 操作 | 数组 | 链表 |
|------|------|------|
| 访问 | O(1) | O(n) |
| 头部插入 | O(n) | O(1) |
| 尾部插入 | O(1) | O(1)* |
| 头部删除 | O(n) | O(1) |
| 尾部删除 | O(1) | O(n) |
| 中间插入/删除 | O(n) | O(n)** |

> * 需要维护 tail 指针  
> ** 查找位置需要 O(n)

---

## 五、虚拟头节点（哑节点）

在处理链表头部的边界问题时，使用虚拟头节点可以简化代码：

```typescript
class LinkedListWithDummy<T> {
    private dummy: ListNode<T>;
    private tail: ListNode<T>;
    
    constructor() {
        this.dummy = new ListNode(null as any);
        this.tail = this.dummy;
    }
    
    add(value: T): void {
        this.tail.next = new ListNode(value);
        this.tail = this.tail.next;
    }
    
    delete(index: number): boolean {
        let prev: ListNode<T> = this.dummy;
        for (let i = 0; i < index; i++) {
            if (!prev.next) return false;
            prev = prev.next;
        }
        if (prev.next) {
            prev.next = prev.next.next;
            return true;
        }
        return false;
    }
}
```

---

## 六、应用场景

| 场景 | 推荐链表类型 |
|------|-------------|
| LRU 缓存 | 双向链表 |
| 哈希表冲突解决 | 单向链表 |
| 撤销/重做功能 | 双向链表 |
| 音乐播放列表 | 循环链表 |
| 浏览器历史记录 | 双向链表 |

---

## 七、总结

- 链表是**动态数据结构**，适合频繁插入删除
- 需要O(1)头部操作时，链表优于数组
- 双向链表可以O(1)删除节点（需要前置指针）
- 注意边界条件（空链表、头节点、尾节点）
- 虚拟头节点可以简化代码
